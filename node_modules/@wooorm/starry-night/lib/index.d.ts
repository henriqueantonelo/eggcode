/**
 * Create a `StarryNight` that can highlight things with the given
 * `grammars`.
 * This is async to allow async loading and registering, which is currently
 * only used for WASM.
 *
 * @param {ReadonlyArray<Grammar>} grammars
 *   Grammars to support.
 * @param {Readonly<Options> | null | undefined} [options]
 *   Configuration (optional).
 * @returns
 *   Promise that resolves to an instance which highlights with the bound
 *   grammars.
 */
export function createStarryNight(grammars: ReadonlyArray<Grammar>, options?: Readonly<Options> | null | undefined): Promise<{
    flagToScope: (flag: string) => string | undefined;
    highlight: (value: string, scope: string) => Root;
    missingScopes: () => ReadonlyArray<string>;
    register: (grammars: ReadonlyArray<Readonly<Grammar>>) => Promise<undefined>;
    scopes: () => ReadonlyArray<string>;
}>;
export type Root = import('hast').Root;
export type IGrammar = import('vscode-textmate').IGrammar;
export type IRawGrammar = import('vscode-textmate').IRawGrammar;
/**
 * Rule `captures` field.
 */
export type Captures = Record<string, Rule>;
/**
 * Get a URL to the oniguruma WASM.
 *
 * > 👉 **Note**: this must currently result in a version 1 URL of
 * > `onig.wasm` from `vscode-oniguruma`.
 *
 * > ⚠️ **Danger**: when you use this functionality, your project might break at
 * > any time (when reinstalling dependencies), except when you make sure that
 * > the WASM binary you load manually is what our internally used
 * > `vscode-oniguruma` dependency expects.
 * > To solve this, you could for example use an npm script called `dependencies`
 * > (which runs everytime `node_modules` is changed) which copies
 * > `vscode-oniguruma/release/onig.wasm` to the place you want to host it.
 */
export type GetOnigurumaUrl = () => Promise<Readonly<URL>> | Readonly<URL>;
/**
 * TextMate grammar with some extra info.
 */
export type Grammar = {
    /**
     * List of scopes that are needed for this grammar to work (optional,
     * example: `['source.tsx']`).
     */
    dependencies?: Array<string>;
    /**
     *   List of extensions (example: `['.mdx']`).
     */
    extensions: Array<string>;
    /**
     * List of extensions that only match if used w/ a dot (optional, example:
     * `['.php']`).
     */
    extensionsWithDot?: Array<string>;
    /**
     * TextMate injections (optional).
     */
    injections?: Record<string, Rule>;
    /**
     *   List of names (example: `['mdx']`).
     */
    names: Array<string>;
    /**
     *   TextMate patterns.
     */
    patterns: Array<Rule>;
    /**
     * TextMate repository (optional).
     */
    repository?: Record<string, Rule>;
    /**
     *   Scope (example: `source.mdx`).
     */
    scopeName: string;
};
/**
 * Configuration (optional).
 */
export type Options = {
    /**
     * Get a URL to the oniguruma WASM, typically used in browsers (optional).
     */
    getOnigurumaUrlFetch?: GetOnigurumaUrl | null | undefined;
    /**
     * Get a URL to the oniguruma WASM, typically used in Node.js (optional).
     */
    getOnigurumaUrlFs?: GetOnigurumaUrl | null | undefined;
};
/**
 * TextMate rule.
 */
export type Rule = RuleDefinition | RuleInclude | RuleName;
export type RuleDefinition = {
    applyEndPatternLast?: boolean;
    begin?: string;
    beginCaptures?: Captures;
    captures?: Captures;
    contentName?: string;
    end?: string;
    endCaptures?: Captures;
    injections?: Record<string, Rule>;
    match?: string;
    name?: string;
    patterns?: Array<Rule>;
    repository?: Record<string, Rule>;
    while?: string;
    whileCaptures?: Captures;
};
export type RuleInclude = {
    begin?: string;
    end?: string;
    include: string;
    match?: string;
    name?: string;
};
export type RuleName = {
    begin?: never;
    include?: never;
    match?: never;
    name: string;
};
//# sourceMappingURL=index.d.ts.map